---
layout:     post
title:      003-机器学习术语表
subtitle:    "\"003-机器学习术语表\""
date:       2018-09-25
author:     PZ
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - ML
    - 理论
---



> https://developers.google.cn/machine-learning/crash-course/glossary#feature

[TOC]

<h1 itemprop="name" class="devsite-page-title">
    机器学习术语表
  </h1>
  
  
  <nav class="devsite-page-nav-embedded devsite-nav"></nav>
  
  <div class="devsite-article-body clearfix
            "
       itemprop="articleBody">
    
<p>本术语表中列出了一般的机器学习术语和 TensorFlow 专用术语的定义。</p>

<h2 class="glossary">A</h2>

<p><a name="AB_testing"></a>
</p><h2 class="hide-from-toc">A/B 测试 (A/B testing)</h2><p></p>
<p>一种统计方法，用于将两种或多种技术进行比较，通常是将当前采用的技术与新技术进行比较。A/B 测试不仅旨在确定哪种技术的效果更好，而且还有助于了解相应差异是否具有显著的统计意义。A/B 测试通常是采用一种衡量方式对两种技术进行比较，但也适用于任意有限数量的技术和衡量方式。</p>
<p><a name="accuracy"></a>
</p><h2 class="hide-from-toc">准确率 (accuracy)</h2><p></p>
<p><a href="#classification_model"><strong>分类模型</strong></a>的正确预测所占的比例。在<a href="#multi-class"><strong>多类别分类</strong></a>中，准确率的定义如下：</p>
<div>
$$\text{准确率} = \frac{\text{正确的预测数}} {\text{样本总数}}$$
</div>

<p>在<a href="#binary_classification"><strong>二元分类</strong></a>中，准确率的定义如下：</p>
<div>
$$\text{准确率} = \frac{\text{真正例数} + \text{真负例数}} {\text{样本总数}}$$
</div>



<p>请参阅<a href="#TP"><strong>真正例</strong></a>和<a href="#TN"><strong>真负例</strong></a>。</p>
<p><a name="activation_function"></a>
</p><h2 class="hide-from-toc">激活函数 (activation function)</h2><p></p>
<p>一种函数（例如 <a href="#ReLU"><strong>ReLU</strong></a> 或 <a href="#sigmoid_function"><strong>S 型</strong></a>函数），用于对上一层的所有输入求加权和，然后生成一个输出值（通常为非线性值），并将其传递给下一层。</p>
<p><a name="AdaGrad"></a>
</p><h2 class="hide-from-toc">AdaGrad</h2><p></p>
<p>一种先进的梯度下降法，用于重新调整每个参数的梯度，以便有效地为每个参数指定独立的<a href="#learning_rate"><strong>学习速率</strong></a>。如需查看完整的解释，请参阅<a href="http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf">这篇论文</a>。</p>
<p><a name="AUC"></a>
</p><h2 class="hide-from-toc">ROC 曲线下面积 (AUC, Area under the ROC Curve)</h2><p></p>
<p>一种会考虑所有可能分类阈值的评估指标<a href="#classification_threshold"><strong></strong></a>。</p>
<p><a href="#ROC">ROC 曲线</a>下面积是，对于随机选择的正类别样本确实为正类别，以及随机选择的负类别样本为正类别，分类器更确信前者的概率。</p>
<h2 class="glossary">B</h2>

<p><a name="backpropagation"></a>
</p><h2 class="hide-from-toc">反向传播算法 (backpropagation)</h2><p></p>
<p>在<a href="#neural_network"><strong>神经网络</strong></a>上执行<a href="#gradient_descent"><strong>梯度下降法</strong></a>的主要算法。该算法会先按前向传播方式计算（并缓存）每个节点的输出值，然后再按反向传播遍历图的方式计算损失函数值相对于每个参数的<a href="https://en.wikipedia.org/wiki/Partial_derivative">偏导数</a>。</p>
<p><a name="baseline"></a>
</p><h2 class="hide-from-toc">基准 (baseline)</h2><p></p>
<p>一种简单的<a href="#model"><strong>模型</strong></a>或启发法，用作比较模型效果时的参考点。基准有助于模型开发者针对特定问题量化最低预期效果。</p>
<p><a name="batch"></a>
</p><h2 class="hide-from-toc">批次 (batch)</h2><p></p>
<p><a href="#model_training"><strong>模型训练</strong></a>的一次<a href="#iteration"><strong>迭代</strong></a>（即一次<a href="#gradient"><strong>梯度</strong></a>更新）中使用的样本集。</p>
<p>另请参阅<a href="#batch_size"><strong>批次规模</strong></a>。</p>
<p><a name="batch_size"></a>
</p><h2 class="hide-from-toc">批次规模 (batch size)</h2><p></p>
<p>一个<a href="#batch"><strong>批次</strong></a>中的样本数。例如，<a href="#SGD"><strong>SGD</strong></a> 的批次规模为 1，而<a href="#mini-batch"><strong>小批次</strong></a>的规模通常介于 10 到 1000 之间。批次规模在训练和推断期间通常是固定的；不过，TensorFlow 允许使用动态批次规模。</p>
<p><a name="bias"></a>
</p><h2 class="hide-from-toc">偏差 (bias)</h2><p></p>
<p>距离原点的截距或偏移。偏差（也称为<strong>偏差项</strong>）在机器学习模型中以 b 或 w<sub>0</sub><em></em><i></i> 表示。例如，在下面的公式中，偏差为 b：<em></em></p>
<div>
$$y' = b + w_1x_1 + w_2x_2 + … w_nx_n$$
</div>

<p>请勿与<a href="#prediction_bias"><strong>预测偏差</strong></a>混淆。</p>
<p><a name="binary_classification"></a>
</p><h2 class="hide-from-toc">二元分类 (binary classification)</h2><p></p>
<p>一种分类任务，可输出两种互斥类别之一。例如，对电子邮件进行评估并输出“垃圾邮件”或“非垃圾邮件”的机器学习模型就是一个二元分类器。</p>
<p><a name="binning"></a>
</p><h2 class="hide-from-toc">分箱 (binning)</h2><p></p>
<p>请参阅<a href="#bucketing"><strong>分桶</strong></a>。</p>

</p><p><a name="bucketing"></a>
</p><h2 class="hide-from-toc">分桶 (bucketing)</h2><p></p>
<p>将一个特征（通常是<a href="#continuous_feature"><strong>连续</strong></a>特征）转换成多个二元特征（称为桶或箱），通常是根据值区间进行转换。例如，您可以将温度区间分割为离散分箱，而不是将温度表示成单个连续的浮点特征。假设温度数据可精确到小数点后一位，则可以将介于 0.0 到 15.0 度之间的所有温度都归入一个分箱，将介于 15.1 到 30.0 度之间的所有温度归入第二个分箱，并将介于 30.1 到 50.0 度之间的所有温度归入第三个分箱。</p>
<h2 class="glossary">C</h2>

<p><a name="calibration_layer"></a>
</p><h2 class="hide-from-toc">校准层 (calibration layer)</h2><p></p>
<p>一种预测后调整，通常是为了降低<a href="#prediction_bias"><strong>预测偏差</strong></a>。调整后的预测和概率应与观察到的标签集的分布一致。</p>
<p><a name="candidate_sampling"></a>
</p><h2 class="hide-from-toc">候选采样 (candidate sampling)</h2><p></p>
<p>一种训练时进行的优化，会使用某种函数（例如 softmax）针对所有正类别标签计算概率，但对于负类别标签，则仅针对其随机样本计算概率。例如，如果某个样本的标签为“小猎犬”和“狗”，则候选采样将针对“小猎犬”和“狗”类别输出以及其他类别（猫、棒棒糖、栅栏）的随机子集计算预测概率和相应的损失项。<em></em><em></em><em></em><em></em><em></em><em></em><em></em>这种采样基于的想法是，只要<a href="#positive_class"><strong>正类别</strong></a>始终得到适当的正增强，<a href="#negative_class"><strong>负类别</strong></a>就可以从频率较低的负增强中进行学习，这确实是在实际中观察到的情况。候选采样的目的是，通过不针对所有负类别计算预测结果来提高计算效率。</p>
<p><a name="categorical_data"></a>
</p><h2 class="hide-from-toc">分类数据 (categorical data)</h2><p></p>
<p>一种<a href="#feature"><strong>特征</strong></a>，拥有一组离散的可能值。以某个名为 <code>house style</code> 的分类特征为例，该特征拥有一组离散的可能值（共三个），即 <code>Tudor, ranch, colonial</code>。通过将 <code>house style</code> 表示成分类数据，相应模型可以学习 <code>Tudor</code>、<code>ranch</code> 和 <code>colonial</code> 分别对房价的影响。</p>
<p>有时，离散集中的值是互斥的，只能将其中一个值应用于指定样本。例如，<code>car maker</code> 分类特征可能只允许一个样本有一个值 (<code>Toyota</code>)。在其他情况下，则可以应用多个值。一辆车可能会被喷涂多种不同的颜色，因此，<code>car color</code> 分类特征可能会允许单个样本具有多个值（例如 <code>red</code> 和 <code>white</code>）。</p>
<p>分类特征有时称为<a href="#discrete_feature"><strong>离散特征</strong></a>。</p>
<p>与<a href="#numerical_data"><strong>数值数据</strong></a>相对。</p>
<p><a name="checkpoint"></a>
</p><h2 class="hide-from-toc">检查点 (checkpoint)</h2><p></p>
<p>一种数据，用于捕获模型变量在特定时间的状态。借助检查点，可以导出模型<a href="#weight"><strong>权重</strong></a>，跨多个会话执行训练，以及使训练在发生错误之后得以继续（例如作业抢占）。请注意，<a href="#graph"><strong>图</strong></a>本身不包含在检查点中。</p>
<p><a name="class"></a>
</p><h2 class="hide-from-toc">类别 (class)</h2><p></p>
<p>为标签枚举的一组目标值中的一个。例如，在检测垃圾邮件的<a href="#binary_classification"><strong>二元分类</strong></a>模型中，两种类别分别是“垃圾邮件”和“非垃圾邮件”。<em></em><em></em>在识别狗品种的<a href="#multi_class_classification"><strong>多类别分类</strong></a>模型中，类别可以是“贵宾犬”、“小猎犬”、“哈巴犬”等等。<em></em><em></em><em></em></p>
<p><a name="class_imbalanced_data_set"></a>
</p><h2 class="hide-from-toc">分类不平衡的数据集 (class-imbalanced data set)</h2><p></p>
<p>一种<a href="#binary_classification"><strong>二元分类</strong></a>问题，在此类问题中，两种类别的<a href="#label"><strong>标签</strong></a>在出现频率方面具有很大的差距。例如，在某个疾病数据集中，0.0001 的样本具有正类别标签，0.9999 的样本具有负类别标签，这就属于分类不平衡问题；但在某个足球比赛预测器中，0.51 的样本的标签为其中一个球队赢，0.49 的样本的标签为另一个球队赢，这就不属于分类不平衡问题。<em></em></p>
<p><a name="classification_model"></a>
</p><h2 class="hide-from-toc">分类模型 (classification model)</h2><p></p>
<p>一种机器学习模型，用于区分两种或多种离散类别。例如，某个自然语言处理分类模型可以确定输入的句子是法语、西班牙语还是意大利语。请与<a href="#regression_model"><strong>回归模型</strong></a>进行比较。</p>
<p><a name="classification_threshold"></a>
</p><h2 class="hide-from-toc">分类阈值 (classification threshold)</h2><p></p>
<p>一种标量值条件，应用于模型预测的得分，旨在将<a href="#positive_class"><strong>正类别</strong></a>与<a href="#negative_class"><strong>负类别</strong></a>区分开。将<a href="#logistic_regression"><strong>逻辑回归</strong></a>结果映射到<a href="#binary_classification"><strong>二元分类</strong></a>时使用。以某个逻辑回归模型为例，该模型用于确定指定电子邮件是垃圾邮件的概率。如果分类阈值为 0.9，那么逻辑回归值高于 0.9 的电子邮件将被归类为“垃圾邮件”，低于 0.9 的则被归类为“非垃圾邮件”。<em></em><em></em></p>
<p><a name="collaborative_filtering"></a>
</p><h2 class="hide-from-toc">协同过滤 (collaborative filtering)</h2><p></p>
<p>根据很多其他用户的兴趣来预测某位用户的兴趣。协同过滤通常用在推荐系统中。</p>
<p><a name="confusion_matrix"></a>
</p><h2 class="hide-from-toc">混淆矩阵 (confusion matrix)</h2><p></p>
<p>一种 NxN 表格，用于总结<a href="#classification_model"><strong>分类模型</strong></a>的预测成效；即标签和模型预测的分类之间的关联。在混淆矩阵中，一个轴表示模型预测的标签，另一个轴表示实际标签。N 表示类别个数。在<a href="#binary_classification"><strong>二元分类</strong></a>问题中，N=2。例如，下面显示了一个二元分类问题的混淆矩阵示例：</p>
<table>
<thead>
<tr>
<th></th>
<th>肿瘤（预测的标签）</th>
<th>非肿瘤（预测的标签）</th>
</tr>
</thead>
<tbody>
<tr>
<td>肿瘤（实际标签）</td>
<td>18</td>
<td>1</td>
</tr>
<tr>
<td>非肿瘤（实际标签）</td>
<td>6</td>
<td>452</td>
</tr>
</tbody>
</table>
<p>上面的混淆矩阵显示，在 19 个实际有肿瘤的样本中，该模型正确地将 18 个归类为有肿瘤（18 个真正例），错误地将 1 个归类为没有肿瘤（1 个假负例）。同样，在 458 个实际没有肿瘤的样本中，模型归类正确的有 452 个（452 个真负例），归类错误的有 6 个（6 个假正例）。</p>
<p>多类别分类问题的混淆矩阵有助于确定出错模式。例如，某个混淆矩阵可以揭示，某个经过训练以识别手写数字的模型往往会将 4 错误地预测为 9，将 7 错误地预测为 1。混淆矩阵包含计算各种效果指标（包括精确率和召回率）所需的充足信息。</p>
<p><a name="continuous_feature"></a>
</p><h2 class="hide-from-toc">连续特征 (continuous feature)</h2><p></p>
<p>一种浮点特征，可能值的区间不受限制。与<a href="#discrete_feature"><strong>离散特征</strong></a>相对。</p>
<p><a name="convergence"></a>
</p><h2 class="hide-from-toc">收敛 (convergence)</h2><p></p>
<p>通俗来说，收敛通常是指在训练期间达到的一种状态，即经过一定次数的迭代之后，训练<a href="#loss"><strong>损失</strong></a>和验证损失在每次迭代中的变化都非常小或根本没有变化。也就是说，如果采用当前数据进行额外的训练将无法改进模型，模型即达到收敛状态。在深度学习中，损失值有时会在最终下降之前的多次迭代中保持不变或几乎保持不变，暂时形成收敛的假象。</p>
<p>另请参阅<a href="#early_stopping"><strong>早停法</strong></a>。</p>
<p>另请参阅 Boyd 和 Vandenberghe 合著的 <a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">Convex Optimization</a>（《凸优化》）。</p>
<p><a name="convex_function"></a>
</p><h2 class="hide-from-toc">凸函数 (convex function)</h2><p></p>
<p>一种函数，函数图像以上的区域为<a href="#convex_set"><strong>凸集</strong></a>。典型凸函数的形状类似于字母 <strong>U</strong>。例如，以下都是凸函数：</p>
<p>
<img src="https://developers.google.cn/machine-learning/glossary/images/convex_functions.png" height="300" alt="典型凸函数的形状类似于字母 U。"/>
</p>

<p>相反，以下函数则不是凸函数。请注意图像上方的区域如何不是凸集：</p>

<p>


<p><strong>严格凸函数</strong>只有一个局部最低点，该点也是全局最低点。经典的 U 形函数都是严格凸函数。不过，有些凸函数（例如直线）则不是这样。</p>
<p>很多常见的<a href="#loss_functions"><strong>损失函数</strong></a>（包括下列函数）都是凸函数：</p>
<ul>
<li><a href="#L2_loss"><strong>L<sub>2</sub> 损失函数</strong></a></li>
<li><a href="#Log_Loss"><strong>对数损失函数</strong></a></li>
<li><a href="#L1_regularization"><strong>L<sub>1</sub> 正则化</strong></a></li>
<li><a href="#L2_regularization"><strong>L<sub>2</sub> 正则化</strong></a></li>
</ul>
<p><a href="#gradient_descent"><strong>梯度下降法</strong></a>的很多变体都一定能找到一个接近严格凸函数最小值的点。同样，<a href="#SGD"><strong>随机梯度下降法</strong></a>的很多变体都有很高的可能性能够找到接近严格凸函数最小值的点（但并非一定能找到）。</p>
<p>两个凸函数的和（例如 L<sub>2</sub> 损失函数 + L<sub>1</sub> 正则化）也是凸函数。</p>
<p><a href="#deep_model"><strong>深度模型</strong></a>绝不会是凸函数。值得注意的是，专门针对<a href="#convex_optimization"><strong>凸优化</strong></a>设计的算法往往总能在深度网络上找到非常好的解决方案，虽然这些解决方案并不一定对应于全局最小值。</p>
<p><a name="convex_optimization"></a>
</p><h2 class="hide-from-toc">凸优化 (convex optimization)</h2><p></p>
<p>使用数学方法（例如<a href="#gradient_descent"><strong>梯度下降法</strong></a>）寻找<a href="#convex_function"><strong>凸函数</strong></a>最小值的过程。机器学习方面的大量研究都是专注于如何通过公式将各种问题表示成凸优化问题，以及如何更高效地解决这些问题。</p>
<p>如需完整的详细信息，请参阅 Boyd 和 Vandenberghe 合著的 <a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">Convex Optimization</a>（《凸优化》）。</p>
<p><a name="convex_set"></a>
</p><h2 class="hide-from-toc">凸集 (convex set)</h2><p></p>
<p>欧几里得空间的一个子集，其中任意两点之间的连线仍完全落在该子集内。例如，下面的两个图形都是凸集：</p>
<p>
<img src="https://developers.google.cn/machine-learning/glossary/images/convex_set.png" alt="矩形和半椭圆形都是凸集。"/>
</p>

<p>相反，下面的两个图形都不是凸集：</p>
<p>
<img src="https://developers.google.cn/machine-learning/glossary/images/nonconvex_set.png" alt="缺少一块的饼图以及烟花图都是非凸集。"/>
</p>

<p><a name="cost"></a>
</p><h2 class="hide-from-toc">成本 (cost)</h2><p></p>
<p>是<a href="#loss"><strong>损失</strong></a>的同义词。</p>
<p><a name="cross-entropy"></a>
</p><h2 class="hide-from-toc">交叉熵 (cross-entropy)</h2><p></p>
<p><a href="#Log_Loss"><strong>对数损失函数</strong></a>向<a href="#multi-class"><strong>多类别分类问题</strong></a>进行的一种泛化。交叉熵可以量化两种概率分布之间的差异。另请参阅<a href="#perplexity"><strong>困惑度</strong></a>。</p>
<p><a name="custom_estimator"></a>
</p><h2 class="hide-from-toc">自定义 Estimator (custom Estimator)</h2><p></p>
<p>您按照<a href="https://tensorflow.google.cn/extend/estimators">这些说明</a>自行编写的 <a href="#Estimators"><strong>Estimator</strong></a>。</p>
<p>与<a href="#pre-made_Estimator"><strong>预创建的 Estimator</strong></a> 相对。</p>
<h2 class="glossary">D</h2>

<p><a name="data_set"></a>
</p><h2 class="hide-from-toc">数据集 (data set)</h2><p></p>
<p>一组<a href="#example"><strong>样本</strong></a>的集合。</p>
<p><a name="dataset_API"></a>
</p><h2 class="hide-from-toc">Dataset API (tf.data)</h2><p></p>
<p>一种高级别的 TensorFlow API，用于读取数据并将其转换为机器学习算法所需的格式。<code>tf.data.Dataset</code> 对象表示一系列元素，其中每个元素都包含一个或多个<a href="#tensor"><strong>张量</strong></a>。<code>tf.data.Iterator</code> 对象可获取 <code>Dataset</code> 中的元素。</p>
<p>如需详细了解 Dataset API，请参阅《TensorFlow 编程人员指南》中的<a href="https://tensorflow.google.cn/programmers_guide/datasets">导入数据</a>。</p>
<p><a name="decision_boundary"></a>
</p><h2 class="hide-from-toc">决策边界 (decision boundary)</h2><p></p>
<p>在<a href="#binary_classification"><strong>二元分类</strong></a>或<a href="#multi-class"><strong>多类别分类问题</strong></a>中，模型学到的类别之间的分界线。例如，在以下表示某个二元分类问题的图片中，决策边界是橙色类别和蓝色类别之间的分界线：</p>
<p>
<img src="https://developers.google.cn/machine-learning/glossary/images/decision_boundary.png" alt="两种类别之间明确定义的边界。"/>
</p>

<p><a name="dense_layer"></a>
</p><h2 class="hide-from-toc">密集层 (dense layer)</h2><p></p>
<p>是<a href="#fully_connected_layer"><strong>全连接层</strong></a>的同义词。</p>
<p><a name="deep_model"></a>
</p><h2 class="hide-from-toc">深度模型 (deep model)</h2><p></p>
<p>一种<a href="#neural_network"><strong>神经网络</strong></a>，其中包含多个<a href="#hidden_layer"><strong>隐藏层</strong></a>。深度模型依赖于可训练的非线性关系。</p>
<p>与<a href="#wide_model"><strong>宽度模型</strong></a>相对。</p>

</p><p><a name="dense_feature"></a>
</p><h2 class="hide-from-toc">密集特征 (dense feature)</h2><p></p>
<p>一种大部分数值是非零值的<a href="#feature"><strong>特征</strong></a>，通常是一个浮点值<a href="#tensor"><strong>张量</strong></a>。参照<a href="#sparse_features"><strong>稀疏特征</strong></a>。</p>
<p><a name="derived_feature"></a>
</p><h2 class="hide-from-toc">衍生特征 (derived feature)</h2><p></p>
<p>是<a href="#synthetic_feature"><strong>合成特征</strong></a>的同义词。</p>
<p><a name="discrete_feature"></a>
</p><h2 class="hide-from-toc">离散特征 (discrete feature)</h2><p></p>
<p>一种<a href="#feature"><strong>特征</strong></a>，包含有限个可能值。例如，某个值只能是“动物”、“蔬菜”或“矿物”的特征便是一个离散特征（或分类特征）。<em></em><em></em><em></em>与<a href="#continuous_feature"><strong>连续特征</strong></a>相对。</p>
<p><a name="dropout_regularization"></a>
</p><h2 class="hide-from-toc">丢弃正则化 (dropout regularization)</h2><p></p>
<p>一种形式的<a href="#regularization"><strong>正则化</strong></a>，在训练<a href="#neural_network"><strong>神经网络</strong></a>方面非常有用。丢弃正则化的运作机制是，在神经网络层的一个梯度步长中移除随机选择的固定数量的单元。丢弃的单元越多，正则化效果就越强。这类似于训练神经网络以模拟较小网络的指数级规模集成学习。如需完整的详细信息，请参阅 <a href="http://www.jmlr.org/papers/volume15/srivastava14a.old/source/srivastava14a.pdf">Dropout: A Simple Way to Prevent Neural Networks from Overfitting</a>（《丢弃：一种防止神经网络过拟合的简单方法》）。</p>
<p><a name="dynamic_model"></a>
</p><h2 class="hide-from-toc">动态模型 (dynamic model)</h2><p></p>
<p>一种<a href="#model"><strong>模型</strong></a>，以持续更新的方式在线接受训练。也就是说，数据会源源不断地进入这种模型。</p>
<h2 class="glossary">E</h2>

<p><a name="early_stopping"></a>
</p><h2 class="hide-from-toc">早停法 (early stopping)</h2><p></p>
<p>一种<a href="#regularization"><strong>正则化</strong></a>方法，涉及在训练损失仍可以继续减少之前结束模型训练。<em></em>使用早停法时，您会在基于<a href="#validation_set"><strong>验证数据集</strong></a>的损失开始增加（也就是<a href="#generalization"><strong>泛化</strong></a>效果变差）时结束模型训练。</p>
<p><a name="embeddings"></a>
</p><h2 class="hide-from-toc">嵌套 (embeddings)</h2><p></p>
<p>一种分类特征，以连续值特征表示。通常，嵌套是指将高维度向量映射到低维度的空间。例如，您可以采用以下两种方式之一来表示英文句子中的单词：</p>
<ul>
<li>表示成包含百万个元素（高维度）的<a href="#sparse_features"><strong>稀疏向量</strong></a>，其中所有元素都是整数。向量中的每个单元格都表示一个单独的英文单词，单元格中的值表示相应单词在句子中出现的次数。由于单个英文句子包含的单词不太可能超过 50 个，因此向量中几乎每个单元格都包含 0。少数非 0 的单元格中将包含一个非常小的整数（通常为 1），该整数表示相应单词在句子中出现的次数。</li>
<li>表示成包含数百个元素（低维度）的<a href="#dense_feature"><strong>密集向量</strong></a>，其中每个元素都包含一个介于 0 到 1 之间的浮点值。这就是一种嵌套。</li>
</ul>
<p>在 TensorFlow 中，会按<a href="#backpropagation"><strong>反向传播</strong></a><a href="#loss"><strong>损失</strong></a>训练嵌套，和训练<a href="#neural_network"><strong>神经网络</strong></a>中的任何其他参数时一样。</p>
<p><a name="ERM"></a>
</p><h2 class="hide-from-toc">经验风险最小化 (ERM, empirical risk minimization)</h2><p></p>
<p>用于选择可以将基于训练集的损失降至最低的模型函数。与<a href="#SRM"><strong>结构风险最小化</strong></a>相对。</p>
<p><a name="ensemble"></a>
</p><h2 class="hide-from-toc">集成学习 (ensemble)</h2><p></p>
<p>多个<a href="#model"><strong>模型</strong></a>的预测结果的并集。您可以通过以下一项或多项来创建集成学习：</p>
<ul>
<li>不同的初始化</li>
<li>不同的<a href="#hyperparameter"><strong>超参数</strong></a></li>
<li>不同的整体结构</li>
</ul>
<p><a href="https://tensorflow.google.cn/tutorials/wide_and_deep">深度模型和宽度模型</a>属于一种集成学习。

</p><p><a name="epoch"></a>
</p><h2 class="hide-from-toc">周期 (epoch)</h2><p></p>
<p>在训练时，整个数据集的一次完整遍历，以便不漏掉任何一个样本。因此，一个周期表示（<code>N</code>/<a href="#batch_size"><strong>批次规模</strong></a>）次训练<a href="#iteration"><strong>迭代</strong></a>，其中 <code>N</code> 是样本总数。</p>
<p><a name="Estimators"></a>
</p><h2 class="hide-from-toc">Estimator</h2><p></p>
<p><code>tf.Estimator</code> 类的一个实例，用于封装负责构建 TensorFlow 图并运行 TensorFlow 会话的逻辑。您可以创建自己的<a href="#custom_estimator"><strong>自定义 Estimator</strong></a>（如需相关介绍，请<a href="https://tensorflow.google.cn/extend/estimators">点击此处</a>），也可以将其他人<a href="#pre-made_Estimator"><strong>预创建的 Estimator</strong></a> 实例化。</p>
<p><a name="example"></a>
</p><h2 class="hide-from-toc">样本 (example)</h2><p></p>
<p>数据集的一行。一个样本包含一个或多个<a href="#feature"><strong>特征</strong></a>，此外还可能包含一个<a href="#label"><strong>标签</strong></a>。另请参阅<a href="#labeled_example"><strong>有标签样本</strong></a>和<a href="#unlabeled_example"><strong>无标签样本</strong></a>。</p>
<h2 class="glossary">F</h2>

<p><a name="FN"></a>
</p><h2 class="hide-from-toc">假负例 (FN, false negative)</h2><p></p>
<p>被模型错误地预测为<a href="#negative_class"><strong>负类别</strong></a>的样本。例如，模型推断出某封电子邮件不是垃圾邮件（负类别），但该电子邮件其实是垃圾邮件。</p>
<p><a name="false_positive"></a>
</p><h2 class="hide-from-toc">假正例 (FP, false positive)</h2><p></p>
<p>被模型错误地预测为<a href="#positive_class"><strong>正类别</strong></a>的样本。例如，模型推断出某封电子邮件是垃圾邮件（正类别），但该电子邮件其实不是垃圾邮件。</p>
<p><a name="FP_rate"></a>
</p><h2 class="hide-from-toc">假正例率（false positive rate, 简称 FP 率）</h2><p></p>
<p><a href="#ROC"><strong>ROC 曲线</strong></a>中的 x 轴。FP 率的定义如下：</p>
<div>
$$\text{假正例率} = \frac{\text{假正例数}}{\text{假正例数} + \text{真负例数}}$$
</div>

<p><a name="feature"></a>
</p><h2 class="hide-from-toc">特征 (feature)</h2><p></p>
<p>在进行<a href="#prediction"><strong>预测</strong></a>时使用的输入变量。</p>
<p><a name="feature_columns"></a>
</p><h2 class="hide-from-toc">特征列 (FeatureColumns)</h2><p></p>
<p>一组相关特征，例如用户可能居住的所有国家/地区的集合。样本的特征列中可能包含一个或多个特征。</p>
<p>TensorFlow 中的特征列内还封装了元数据，例如：</p>
<ul>
<li>特征的数据类型</li>
<li>特征是固定长度还是应转换为嵌套</li>
</ul>
<p>特征列可以包含单个特征。</p>
<p>“特征列”是 Google 专用的术语。特征列在 Yahoo/Microsoft 使用的 <a href="https://en.wikipedia.org/wiki/Vowpal_Wabbit">VW</a> 系统中称为“命名空间”，也称为<a href="https://www.csie.ntu.edu.tw/~cjlin/libffm/">场</a>。</p>
<p><a name="feature_cross"></a>
</p><h2 class="hide-from-toc">特征组合 (feature cross)</h2><p></p>
<p>通过将单独的特征进行组合（相乘或求笛卡尔积）而形成的<a href="#synthetic_feature"><strong>合成特征</strong></a>。特征组合有助于表示非线性关系。</p>
<p><a name="feature_engineering"></a>
</p><h2 class="hide-from-toc">特征工程 (feature engineering)</h2><p></p>
<p>指以下过程：确定哪些<a href="#feature"><strong>特征</strong></a>可能在训练模型方面非常有用，然后将日志文件及其他来源的原始数据转换为所需的特征。在 TensorFlow 中，特征工程通常是指将原始日志文件条目转换为 <a href="#tf.Example"><strong>tf.Example</strong></a> proto buffer。另请参阅 <a href="https://github.com/tensorflow/transform">tf.Transform</a>。</p>
<p>特征工程有时称为<strong>特征提取</strong>。</p>
<p><a name="feature_set"></a>
</p><h2 class="hide-from-toc">特征集 (feature set)</h2><p></p>
<p>训练机器学习模型时采用的一组<a href="#feature"><strong>特征</strong></a>。例如，对于某个用于预测房价的模型，邮政编码、房屋面积以及房屋状况可以组成一个简单的特征集。</p>
<p><a name="feature_spec"></a>
</p><h2 class="hide-from-toc">特征规范 (feature spec)</h2><p></p>
<p>用于描述如何从 <a href="#tf.Example"><strong>tf.Example</strong></a> proto buffer 提取<a href="#feature"><strong>特征</strong></a>数据。由于 tf.Example proto buffer 只是一个数据容器，因此您必须指定以下内容：</p>
<ul>
<li>要提取的数据（即特征的键）</li>
<li>数据类型（例如 float 或 int）</li>
<li>长度（固定或可变）</li>
</ul>
<p><a href="#Estimators"><strong>Estimator API</strong></a> 提供了一些可用来根据给定 <a href="#feature_columns"><strong>FeatureColumns</strong></a> 列表生成特征规范的工具。</p>
<p><a name="full_softmax"></a>
</p><h2 class="hide-from-toc">完整 softmax (full softmax)</h2><p></p>
<p>请参阅 <a href="#softmax"><strong>softmax</strong></a>。与<a href="#candidate_sampling"><strong>候选采样</strong></a>相对。</p>
<p><a name="fully_connected_layer"></a>
</p><h2 class="hide-from-toc">全连接层 (fully connected layer)</h2><p></p>
<p>一种<a href="#hidden_layer"><strong>隐藏层</strong></a>，其中的每个<a href="#node"><strong>节点</strong></a>均与下一个隐藏层中的每个节点相连。<em></em></p>
<p>全连接层又称为<a href="#dense_layer"><strong>密集层</strong></a>。</p>
<h2 class="glossary">G</h2>


</p><p><a name="generalization"></a>
</p><h2 class="hide-from-toc">泛化 (generalization)</h2><p></p>
<p>指的是模型依据训练时采用的数据，针对以前未见过的新数据做出正确预测的能力。</p>
<p><a name="generalized_linear_model"></a>
</p><h2 class="hide-from-toc">广义线性模型 (generalized linear model)</h2><p></p>
<p><a href="https://developers.google.cn/machine-learning/crash-course/least_squares_regression"><strong>最小二乘回归</strong></a>模型（基于<a href="https://en.wikipedia.org/wiki/Gaussian_noise">高斯噪声</a>）向其他类型的模型（基于其他类型的噪声，例如<a href="https://en.wikipedia.org/wiki/Shot_noise">泊松噪声</a>或分类噪声）进行的一种泛化。广义线性模型的示例包括：</p>
<ul>
<li><a href="#logistic_regression"><strong>逻辑回归</strong></a></li>
<li>多类别回归</li>
<li>最小二乘回归</li>
</ul>
<p>可以通过<a href="https://en.wikipedia.org/wiki/Convex_optimization">凸优化</a>找到广义线性模型的参数。</p>
<p>广义线性模型具有以下特性：</p>
<ul>
<li>最优的最小二乘回归模型的平均预测结果等于训练数据的平均标签。</li>
<li>最优的逻辑回归模型预测的平均概率等于训练数据的平均标签。</li>
</ul>
<p>广义线性模型的功能受其特征的限制。与深度模型不同，广义线性模型无法“学习新特征”。</p>
<p><a name="gradient"></a>
</p><h2 class="hide-from-toc">梯度 (gradient)</h2><p></p>
<p><a href="#partial_derivative"><strong>偏导数</strong></a>相对于所有自变量的向量。在机器学习中，梯度是模型函数偏导数的向量。梯度指向最速上升的方向。</p>
<p><a name="gradient_clipping"></a>
</p><h2 class="hide-from-toc">梯度裁剪 (gradient clipping)</h2><p></p>
<p>在应用<a href="#gradient"><strong>梯度</strong></a>值之前先设置其上限。梯度裁剪有助于确保数值稳定性以及防止<a href="http://www.cs.toronto.edu/~rgrosse/courses/csc321_2017/readings/L15%20Exploding%20and%20Vanishing%20Gradients.pdf">梯度爆炸</a>。</p>
<p><a name="gradient_descent"></a>
</p><h2 class="hide-from-toc">梯度下降法 (gradient descent)</h2><p></p>
<p>一种通过计算并且减小梯度将<a href="#loss"><strong>损失</strong></a>降至最低的技术，它以训练数据为条件，来计算损失相对于模型参数的梯度。通俗来说，梯度下降法以迭代方式调整参数，逐渐找到<a href="#weight"><strong>权重</strong></a>和偏差的最佳组合，从而将损失降至最低。</p>
<p><a name="graph"></a>
</p><h2 class="hide-from-toc">图 (graph)</h2><p></p>
<p>TensorFlow 中的一种计算规范。图中的节点表示操作。边缘具有方向，表示将某项操作的结果（一个<a href="https://tensorflow.google.cn/api_docs/python/tf/Tensor">张量</a>）作为一个操作数传递给另一项操作。可以使用 <a href="#TensorBoard"><strong>TensorBoard</strong></a> 直观呈现图。</p>
<h2 class="glossary">H</h2>

<p><a name="heuristic"></a>
</p><h2 class="hide-from-toc">启发法 (heuristic)</h2><p></p>
<p>一种非最优但实用的问题解决方案，足以用于进行改进或从中学习。</p>
<p><a name="hidden_layer"></a>
</p><h2 class="hide-from-toc">隐藏层 (hidden layer)</h2><p></p>
<p><a href="#neural_network"><strong>神经网络</strong></a>中的合成层，介于<a href="#input_layer"><strong>输入层</strong></a>（即特征）和<a href="#output_layer"><strong>输出层</strong></a>（即预测）之间。神经网络包含一个或多个隐藏层。</p>
<p><a name="hinge-loss"></a>
</p><h2 class="hide-from-toc">合页损失函数 (hinge loss)</h2><p></p>
<p>一系列用于<a href="#classification_model"><strong>分类</strong></a>的<a href="#loss"><strong>损失</strong></a>函数，旨在找到距离每个训练样本都尽可能远的<a href="#decision_boundary"><strong>决策边界</strong></a>，从而使样本和边界之间的裕度最大化。
<a href="#KSVMs"><strong>KSVM</strong></a> 使用合页损失函数（或相关函数，例如平方合页损失函数）。对于二元分类，合页损失函数的定义如下：</p>
<div>
$$\text{loss} = \text{max}(0, 1 - (y' * y))$$
</div>

<p>其中“y'”表示分类器模型的原始输出：<em></em></p>
<div>
$$y' = b + w_1x_1 + w_2x_2 + … w_nx_n$$
</div>

<p>“y”表示真标签，值为 -1 或 +1。<em></em></p>
<p>因此，合页损失与 (y * y') 的关系图如下所示：</p>

<p>

</p>

<p><a name="holdout_data"></a>
</p><h2 class="hide-from-toc">维持数据 (holdout data)</h2><p></p>
<p>训练期间故意不使用（“维持”）的<a href="#example"><strong>样本</strong></a>。<a href="#validation_set"><strong>验证数据集</strong></a>和<a href="#test_set"><strong>测试数据集</strong></a>都属于维持数据。维持数据有助于评估模型向训练时所用数据之外的数据进行泛化的能力。与基于训练数据集的损失相比，基于维持数据集的损失有助于更好地估算基于未见过的数据集的损失。</p>
<p><a name="hyperparameter"></a>
</p><h2 class="hide-from-toc">超参数 (hyperparameter)</h2><p></p>
<p>在模型训练的连续过程中，您调节的“旋钮”。例如，<a href="#learning_rate"><strong>学习速率</strong></a>就是一种超参数。</p>
<p>与<a href="#parameter"><strong>参数</strong></a>相对。</p>
<p><a name="hyperplane"></a>
</p><h2 class="hide-from-toc">超平面 (hyperplane)</h2><p></p>
<p>将一个空间划分为两个子空间的边界。例如，在二维空间中，直线就是一个超平面，在三维空间中，平面则是一个超平面。在机器学习中更典型的是：超平面是分隔高维度空间的边界。<a href="#KSVMs"><strong>核支持向量机</strong></a>利用超平面将正类别和负类别区分开来（通常是在极高维度空间中）。</p>
<h2 class="glossary">I</h2>

<p><a name="iid"></a>
</p><h2 class="hide-from-toc">独立同分布 (i.i.d, independently and identically distributed)</h2><p></p>
<p>从不会改变的分布中提取的数据，其中提取的每个值都不依赖于之前提取的值。i.i.d. 是机器学习的<a href="https://en.wikipedia.org/wiki/Ideal_gas">理想气体</a> - 一种实用的数学结构，但在现实世界中几乎从未发现过。例如，某个网页的访问者在短时间内的分布可能为 i.i.d.，即分布在该短时间内没有变化，且一位用户的访问行为通常与另一位用户的访问行为无关。不过，如果将时间窗口扩大，网页访问者的分布可能呈现出季节性变化。</p>
<p><a name="inference"></a>
</p><h2 class="hide-from-toc">推断 (inference)</h2><p></p>
<p>在机器学习中，推断通常指以下过程：通过将训练过的模型应用于<a href="#unlabeled_example"><strong>无标签样本</strong></a>来做出预测。在统计学中，推断是指在某些观测数据条件下拟合分布参数的过程。（请参阅<a href="https://en.wikipedia.org/wiki/Statistical_inference">维基百科中有关统计学推断的文章</a>。）</p>
<p><a name="input_function"></a>
</p><h2 class="hide-from-toc">输入函数 (input function)</h2><p></p>
<p>在 TensorFlow 中，用于将输入数据返回到 <a href="#Estimators"><strong>Estimator</strong></a> 的训练、评估或预测方法的函数。例如，训练输入函数用于返回<a href="#training_set"><strong>训练集</strong></a>中的<a href="#batch"><strong>批次</strong></a>特征和标签。</p>
<p><a name="input_layer"></a>
</p><h2 class="hide-from-toc">输入层 (input layer)</h2><p></p>
<p><a href="#neural_network"><strong>神经网络</strong></a>中的第一层（接收输入数据的层）。</p>
<p><a name="instance"></a>
</p><h2 class="hide-from-toc">实例 (instance)</h2><p></p>
<p>是<a href="#example"><strong>样本</strong></a>的同义词。</p>
<p><a name="interpretability"></a>
</p><h2 class="hide-from-toc">可解释性 (interpretability)</h2><p></p>
<p>模型的预测可解释的难易程度。深度模型通常不可解释，也就是说，很难对深度模型的不同层进行解释。相比之下，线性回归模型和<a href="#wide_model"><strong>宽度模型</strong></a>的可解释性通常要好得多。</p>
<p><a name="inter-rater_agreement"></a>
</p><h2 class="hide-from-toc">评分者间一致性信度 (inter-rater agreement)</h2><p></p>
<p>一种衡量指标，用于衡量在执行某项任务时评分者达成一致的频率。如果评分者未达成一致，则可能需要改进任务说明。有时也称为<strong>注释者间一致性信度</strong>或<strong>评分者间可靠性信度</strong>。另请参阅 <a href="https://en.wikipedia.org/wiki/Cohen%27s_kappa">Cohen's kappa</a>（最热门的评分者间一致性信度衡量指标之一）。</p>
<p><a name="iteration"></a>
</p><h2 class="hide-from-toc">迭代 (iteration)</h2><p></p>
<p>模型的权重在训练期间的一次更新。迭代包含计算参数在单个<a href="#batch"><strong>批量</strong></a>数据上的梯度损失。</p>
<h2 class="glossary">K</h2>

<p><a name="Keras"></a>
</p><h2 class="hide-from-toc">Keras</h2><p></p>
<p>一种热门的 Python 机器学习 API。<a href="https://keras.io">Keras</a> 能够在多种深度学习框架上运行，其中包括 TensorFlow（在该框架上，Keras 作为 <a href="https://tensorflow.google.cn/api_docs/python/tf/keras"><strong>tf.keras</strong></a> 提供）。</p>
<p><a name="KSVMs"></a>
</p><h2 class="hide-from-toc">核支持向量机 (KSVM, Kernel Support Vector Machines)</h2><p></p>
<p>一种分类算法，旨在通过将输入数据向量映射到更高维度的空间，来最大化<a href="#positive_class"><strong>正类别</strong></a>和<a href="#negative_class"><strong>负类别</strong></a>之间的裕度。以某个输入数据集包含一百个特征的分类问题为例。为了最大化正类别和负类别之间的裕度，KSVM 可以在内部将这些特征映射到百万维度的空间。KSVM 使用<a href="#hinge-loss">合页损失函数</a>。</p>
<h2 class="glossary">L</h2>

<p><a name="L1_loss"></a>
</p><h2 class="hide-from-toc">L<sub>1</sub> 损失函数 (L₁ loss)</h2><p></p>
<p>一种<a href="#loss"><strong>损失</strong></a>函数，基于模型预测的值与<a href="#label"><strong>标签</strong></a>的实际值之差的绝对值。与 <a href="#squared_loss"><strong>L<sub>2</sub> 损失函数</strong></a>相比，L<sub>1</sub> 损失函数对离群值的敏感性弱一些。</p>
<p><a name="L1_regularization"></a>
</p><h2 class="hide-from-toc">L<sub>1</sub> 正则化 (L₁ regularization)</h2><p></p>
<p>一种<a href="#regularization"><strong>正则化</strong></a>，根据权重的绝对值的总和来惩罚权重。在依赖<a href="#sparse_features"><strong>稀疏特征</strong></a>的模型中，L<sub>1</sub> 正则化有助于使不相关或几乎不相关的特征的权重正好为 0，从而将这些特征从模型中移除。与 <a href="#L2_regularization"><strong>L<sub>2</sub> 正则化</strong></a>相对。</p>
<p><a name="L2_loss"></a>
</p><h2 class="hide-from-toc">L<sub>2</sub> 损失函数 (L₂ loss)</h2><p></p>
<p>请参阅<a href="#squared_loss"><strong>平方损失函数</strong></a>。</p>
<p><a name="L2_regularization"></a>
</p><h2 class="hide-from-toc">L<sub>2</sub> 正则化 (L₂ regularization)</h2><p></p>
<p>一种<a href="#regularization"><strong>正则化</strong></a>，根据权重的平方和来惩罚权重。<em></em>L<sub>2</sub> 正则化有助于使离群值（具有较大正值或较小负值）权重接近于 0，但又不正好为 0。（与 <a href="#L1_regularization"><strong>L1 正则化</strong></a>相对。）在线性模型中，L<sub>2</sub> 正则化始终可以改进泛化。</p>
<p><a name="label"></a>
</p><h2 class="hide-from-toc">标签 (label)</h2><p></p>
<p>在监督式学习中，标签指<a href="#example"><strong>样本</strong></a>的“答案”或“结果”部分。有标签数据集中的每个样本都包含一个或多个特征以及一个标签。例如，在房屋数据集中，特征可以包括卧室数、卫生间数以及房龄，而标签则可以是房价。在垃圾邮件检测数据集中，特征可以包括主题行、发件人以及电子邮件本身，而标签则可以是“垃圾邮件”或“非垃圾邮件”。</p>
<p><a name="labeled_example"></a>
</p><h2 class="hide-from-toc">有标签样本 (labeled example)</h2><p></p>
<p>包含<a href="#feature"><strong>特征</strong></a>和<a href="#label"><strong>标签</strong></a>的样本。在监督式训练中，模型从有标签样本中进行学习。</p>
<p><a name="lambda"></a>
</p><h2 class="hide-from-toc">lambda</h2><p></p>
<p>是<a href="#regularization_rate"><strong>正则化率</strong></a>的同义词。</p>
<p>（多含义术语，我们在此关注的是该术语在<a href="#regularization"><strong>正则化</strong></a>中的定义。）</p>
<p><a name="layer"></a>
</p><h2 class="hide-from-toc">层 (layer)</h2><p></p>
<p><a href="#neural_network"><strong>神经网络</strong></a>中的一组<a href="#neuron"><strong>神经元</strong></a>，处理一组输入特征，或一组神经元的输出。</p>
<p>此外还指 TensorFlow 中的抽象层。层是 Python 函数，以<a href="#tensor"><strong>张量</strong></a>和配置选项作为输入，然后生成其他张量作为输出。当必要的张量组合起来，用户便可以通过模型函数将结果转换为 <a href="#Estimators"><strong>Estimator</strong></a>。</p>
<p><a name="layers_API"></a>
</p><h2 class="hide-from-toc">Layers API (tf.layers)</h2><p></p>
<p>一种 TensorFlow API，用于以层组合的方式构建<a href="#deep_model"><strong>深度</strong></a>神经网络。通过 Layers API，您可以构建不同类型的<a href="#layer"><strong>层</strong></a>，例如：</p>
<ul>
<li>通过 <code>tf.layers.Dense</code> 构建<a href="#fully_connected_layer"><strong>全连接层</strong></a>。</li>
<li>通过 <code>tf.layers.Conv2D</code> 构建卷积层。</li>
</ul>
<p>在编写<a href="#custom_estimator"><strong>自定义 Estimator</strong></a> 时，您可以编写“层”对象来定义所有<a href="#hidden_layers"><strong>隐藏层</strong></a>的特征。</p>
<p>Layers API 遵循 [<strong>Keras</strong>](#Keras) layers API 规范。也就是说，除了前缀不同以外，Layers API 中的所有函数均与 Keras layers API 中的对应函数具有相同的名称和签名。</p>
<p><a name="learning_rate"></a>
</p><h2 class="hide-from-toc">学习速率 (learning rate)</h2><p></p>
<p>在训练模型时用于梯度下降的一个变量。在每次迭代期间，<a href="#gradient_descent"><strong>梯度下降法</strong></a>都会将学习速率与梯度相乘。得出的乘积称为<strong>梯度步长</strong>。</p>
<p>学习速率是一个重要的<a href="#hyperparameter"><strong>超参数</strong></a>。</p>
<p><a name="least_squares_regression"></a>
</p><h2 class="hide-from-toc">最小二乘回归 (least squares regression)</h2><p></p>
<p>一种通过最小化 <a href="#L2_loss"><strong>L<sub>2</sub> 损失</strong></a>训练出的线性回归模型。</p>
<p><a name="linear_regression"></a>
</p><h2 class="hide-from-toc">线性回归 (linear regression)</h2><p></p>
<p>一种<a href="#regression_model"><strong>回归模型</strong></a>，通过将输入特征进行线性组合，以连续值作为输出。</p>
<p><a name="logistic_regression"></a>
</p><h2 class="hide-from-toc">逻辑回归 (logistic regression)</h2><p></p>
<p>一种模型，通过将 <a href="#sigmoid_function"><strong>S 型函数</strong></a>应用于线性预测，生成分类问题中每个可能的离散标签值的概率。虽然逻辑回归经常用于<a href="#binary_classification"><strong>二元分类</strong></a>问题，但也可用于<a href="#multi-class"><strong>多类别</strong></a>分类问题（其叫法变为<strong>多类别逻辑回归</strong>或<strong>多项回归</strong>）。</p>
<p><a name="Log_Loss"></a>
</p><h2 class="hide-from-toc">对数损失函数 (Log Loss)</h2><p></p>
<p>二元<a href="#logistic_regression"><strong>逻辑回归</strong></a>中使用的<a href="#loss"><strong>损失</strong></a>函数。</p>
<p><a name="loss"></a>
</p><h2 class="hide-from-toc">损失 (Loss)</h2><p></p>
<p>一种衡量指标，用于衡量模型的<a href="#prediction"><strong>预测</strong></a>偏离其<a href="#label"><strong>标签</strong></a>的程度。或者更悲观地说是衡量模型有多差。要确定此值，模型必须定义损失函数。例如，线性回归模型通常将<a href="#MSE"><strong>均方误差</strong></a>用于损失函数，而逻辑回归模型则使用<a href="#Log_Loss"><strong>对数损失函数</strong></a>。</p>
<h2 class="glossary">M</h2>

<p><a name="machine_learning"></a>
</p><h2 class="hide-from-toc">机器学习 (machine learning)</h2><p></p>
<p>一种程序或系统，用于根据输入数据构建（训练）预测模型。这种系统会利用学到的模型根据从分布（训练该模型时使用的同一分布）中提取的新数据（以前从未见过的数据）进行实用的预测。机器学习还指与这些程序或系统相关的研究领域。</p>
<p><a name="MSE"></a>
</p><h2 class="hide-from-toc">均方误差 (MSE, Mean Squared Error)</h2><p></p>
<p>每个样本的平均平方损失。MSE 的计算方法是<a href="#squared_loss"><strong>平方损失</strong></a>除以<a href="#example"><strong>样本</strong></a>数。<a href="#TensorFlow_Playground"><strong>TensorFlow Playground</strong></a> 显示的“训练损失”值和“测试损失”值都是 MSE。</p>
<p><a name="metric"></a>
</p><h2 class="hide-from-toc">指标 (metric)</h2><p></p>
<p>您关心的一个数值。可能可以也可能不可以直接在机器学习系统中得到优化。您的系统尝试优化的指标称为<a href="#objective"><strong>目标</strong></a>。</p>
<p><a name="metrics_API"></a>
</p><h2 class="hide-from-toc">Metrics API (tf.metrics)</h2><p></p>
<p>一种用于评估模型的 TensorFlow API。例如，<code>tf.metrics.accuracy</code> 用于确定模型的预测与标签匹配的频率。在编写<a href="#custom_estimator"><strong>自定义 Estimator</strong></a> 时，您可以调用 Metrics API 函数来指定应如何评估您的模型。</p>
<p><a name="mini-batch"></a>
</p><h2 class="hide-from-toc">小批次 (mini-batch)</h2><p></p>
<p>从训练或推断过程的一次迭代中一起运行的整批<a href="#example"><strong>样本</strong></a>内随机选择的一小部分。小批次的<a href="#batch_size"><strong>规模</strong></a>通常介于 10 到 1000 之间。与基于完整的训练数据计算损失相比，基于小批次数据计算损失要高效得多。</p>
<p><a name="mini-batch_SGD"></a>
</p><h2 class="hide-from-toc">小批次随机梯度下降法 (SGD, mini-batch stochastic gradient descent)</h2><p></p>
<p>一种采用<a href="#mini-batch"><strong>小批次</strong></a>样本的<a href="#gradient_descent"><strong>梯度下降法</strong></a>。也就是说，小批次 SGD 会根据一小部分训练数据来估算梯度。<a href="#SGD"><strong>Vanilla SGD</strong></a> 使用的小批次的规模为 1。</p>
<p><a name="ML"></a>
</p><h2 class="hide-from-toc">ML</h2><p></p>
<p><a href="#machine_learning"><strong>机器学习</strong></a>的缩写。</p>
<p><a name="model"></a>
</p><h2 class="hide-from-toc">模型 (model)</h2><p></p>
<p>机器学习系统从训练数据学到的内容的表示形式。多含义术语，可以理解为下列两种相关含义之一：</p>
<ul>
<li>一种 <a href="#TensorFlow"><strong>TensorFlow</strong></a> 图，用于表示预测计算结构。</li>
<li>该 TensorFlow 图的特定权重和偏差，通过<a href="#model_training"><strong>训练</strong></a>决定。</li>
</ul>
<p><a name="model_training"></a>
</p><h2 class="hide-from-toc">模型训练 (model training)</h2><p></p>
<p>确定最佳<a href="#model"><strong>模型</strong></a>的过程。</p>
<p><a name="Momentum"></a>
</p><h2 class="hide-from-toc">动量 (Momentum)</h2><p></p>
<p>一种先进的梯度下降法，其中学习步长不仅取决于当前步长的导数，还取决于之前一步或多步的步长的导数。动量涉及计算梯度随时间而变化的指数级加权移动平均值，与物理学中的动量类似。动量有时可以防止学习过程被卡在局部最小的情况。</p>
<p><a name="multi-class"></a>
</p><h2 class="hide-from-toc">多类别分类 (multi-class classification)</h2><p></p>
<p>区分两种以上类别的分类问题。例如，枫树大约有 128 种，因此，确定枫树种类的模型就属于多类别模型。反之，仅将电子邮件分为两类（“垃圾邮件”和“非垃圾邮件”）的模型属于<a href="#binary_classification"><strong>二元分类模型</strong></a>。<em></em><em></em></p>
<p><a name="multinomial_classification"></a>
</p><h2 class="hide-from-toc">多项分类 (multinomial classification)</h2><p></p>
<p>是<a href="#multi-class"><strong>多类别分类</strong></a>的同义词。</p>
<h2 class="glossary">N</h2>

<p><a name="NaN_trap"></a>
</p><h2 class="hide-from-toc">NaN 陷阱 (NaN trap)</h2><p></p>
<p>模型中的一个数字在训练期间变成 <a href="https://en.wikipedia.org/wiki/NaN">NaN</a>，这会导致模型中的很多或所有其他数字最终也会变成 NaN。</p>
<p>NaN 是“非数字”的缩写。</p>
<p><a name="negative_class"></a>
</p><h2 class="hide-from-toc">负类别 (negative class)</h2><p></p>
<p>在<a href="#binary_classification"><strong>二元分类</strong></a>中，一种类别称为正类别，另一种类别称为负类别。正类别是我们要寻找的类别，负类别则是另一种可能性。例如，在医学检查中，负类别可以是“非肿瘤”。在电子邮件分类器中，负类别可以是“非垃圾邮件”。另请参阅<a href="#positive_class"><strong>正类别</strong></a>。</p>
<p><a name="neural_network"></a>
</p><h2 class="hide-from-toc">神经网络 (neural network)</h2><p></p>
<p>一种模型，灵感来源于脑部结构，由多个层构成（至少有一个是<a href="#hidden_layer"><strong>隐藏层</strong></a>），每个层都包含简单相连的单元或<a href="#neuron"><strong>神经元</strong></a>（具有非线性关系）。</p>
<p><a name="neuron"></a>
</p><h2 class="hide-from-toc">神经元 (neuron)</h2><p></p>
<p><a href="#neural_network"><strong>神经网络</strong></a>中的节点，通常是接收多个输入值并生成一个输出值。神经元通过将<a href="#activation_function"><strong>激活函数</strong></a>（非线性转换）应用于输入值的加权和来计算输出值。</p>
<p><a name="node"></a>
</p><h2 class="hide-from-toc">节点 (node)</h2><p></p>
<p>多含义术语，可以理解为下列两种含义之一：</p>
<ul>
<li><a href="#hidden_layer"><strong>隐藏层</strong></a>中的神经元。</li>
<li>TensorFlow <a href="#graph"><strong>图</strong></a>中的操作。</li>
</ul>
<p><a name="normalization"></a>
</p><h2 class="hide-from-toc">标准化 (normalization)</h2><p></p>
<p>将实际的值区间转换为标准的值区间（通常为 -1 到 +1 或 0 到 1）的过程。例如，假设某个特征的自然区间是 800 到 6000。通过减法和除法运算，您可以将这些值标准化为位于 -1 到 +1 区间内。</p>
<p>另请参阅<a href="#scaling"><strong>缩放</strong></a>。</p>
<p><a name="numerical_data"></a>
</p><h2 class="hide-from-toc">数值数据 (numerical data)</h2><p></p>
<p>用整数或实数表示的<a href="#feature"><strong>特征</strong></a>。例如，在房地产模型中，您可能会用数值数据表示房子大小（以平方英尺或平方米为单位）。如果用数值数据表示特征，则可以表明特征的值相互之间具有数学关系，并且与标签可能也有数学关系。<em></em>例如，如果用数值数据表示房子大小，则可以表明面积为 200 平方米的房子是面积为 100 平方米的房子的两倍。此外，房子面积的平方米数可能与房价存在一定的数学关系。</p>
<p>并非所有整数数据都应表示成数值数据。例如，世界上某些地区的邮政编码是整数，但在模型中，不应将整数邮政编码表示成数值数据。这是因为邮政编码 <code>20000</code> 在效力上并不是邮政编码 10000 的两倍（或一半）。此外，虽然不同的邮政编码确实与不同的房地产价值有关，但我们也不能假设邮政编码为 20000 的房地产在价值上是邮政编码为 10000 的房地产的两倍。<em></em>邮政编码应表示成<a href="#categorical_data"><strong>分类数据</strong></a>。</p>
<p>数值特征有时称为<a href="#continuous_feature"><strong>连续特征</strong></a>。</p>
<p><a name="numpy"></a>
</p><h2 class="hide-from-toc">Numpy</h2><p></p>
<p>一个<a href="http://www.numpy.org/">开放源代码数学库</a>，在 Python 中提供高效的数组操作。<a href="#pandas"><strong>Pandas</strong></a> 就建立在 Numpy 之上。</p>
<h2 class="glossary">O</h2>

<p><a name="objective"></a>
</p><h2 class="hide-from-toc">目标 (objective)</h2><p></p>
<p>算法尝试优化的指标。</p>
<p><a name="offline_inference"></a>
</p><h2 class="hide-from-toc">离线推断 (offline inference)</h2><p></p>
<p>生成一组<a href="#prediction"><strong>预测</strong></a>，存储这些预测，然后根据需求检索这些预测。与<a href="#online_inference"><strong>在线推断</strong></a>相对。</p>
<p><a name="one-hot_encoding"></a>
</p><h2 class="hide-from-toc">one-hot 编码 (one-hot encoding)</h2><p></p>
<p>一种稀疏向量，其中：</p>
<ul>
<li>一个元素设为 1。</li>
<li>所有其他元素均设为 0。</li>
</ul>
<p>one-hot 编码常用于表示拥有有限个可能值的字符串或标识符。例如，假设某个指定的植物学数据集记录了 15000 个不同的物种，其中每个物种都用独一无二的字符串标识符来表示。在特征工程过程中，您可能需要将这些字符串标识符编码为 one-hot 向量，向量的大小为 15000。</p>
<p><a name="one-vs.-all"></a>
</p><h2 class="hide-from-toc">一对多 (one-vs.-all)</h2><p></p>
<p>假设某个分类问题有 N 种可能的解决方案，一对多解决方案将包含 N 个单独的<a href="#binary_classification"><strong>二元分类器</strong></a> - 一个二元分类器对应一种可能的结果。例如，假设某个模型用于区分样本属于动物、蔬菜还是矿物，一对多解决方案将提供下列三个单独的二元分类器：</p>
<ul>
<li>动物和非动物</li>
<li>蔬菜和非蔬菜</li>
<li>矿物和非矿物</li>
</ul>
<p><a name="online_inference"></a>
</p><h2 class="hide-from-toc">在线推断 (online inference)</h2><p></p>
<p>根据需求生成<a href="#prediction"><strong>预测</strong></a>。与<a href="#offline_inference"><strong>离线推断</strong></a>相对。</p>
<p><a name="Operation"></a>
</p><h2 class="hide-from-toc">操作 (op, Operation)</h2><p></p>
<p>TensorFlow 图中的节点。在 TensorFlow 中，任何创建、操纵或销毁<a href="#tensor"><strong>张量</strong></a>的过程都属于操作。例如，矩阵相乘就是一种操作，该操作以两个张量作为输入，并生成一个张量作为输出。</p>
<p><a name="optimizer"></a>
</p><h2 class="hide-from-toc">优化器 (optimizer)</h2><p></p>
<p><a href="#gradient_descent"><strong>梯度下降法</strong></a>的一种具体实现。TensorFlow 的优化器基类是 <a href="https://tensorflow.google.cn/api_docs/python/tf/train/Optimizer">tf.train.Optimizer</a>。不同的优化器（<code>tf.train.Optimizer</code> 的子类）会考虑如下概念：</p>
<ul>
<li><a href="https://tensorflow.google.cn/api_docs/python/tf/train/MomentumOptimizer">动量</a>
    (Momentum)</li>
<li>更新频率
    （<a href="https://tensorflow.google.cn/api_docs/python/tf/train/AdagradOptimizer">AdaGrad</a>
    = ADAptive GRADient descent；
    <a href="https://tensorflow.google.cn/api_docs/python/tf/train/AdamOptimizer">Adam</a>
    = ADAptive with Momentum；RMSProp）</li>
<li>稀疏性/正则化
    (<a href="https://tensorflow.google.cn/api_docs/python/tf/train/FtrlOptimizer">Ftrl</a>)</li>
<li>更复杂的计算方法
    （<a href="https://tensorflow.google.cn/api_docs/python/tf/train/ProximalGradientDescentOptimizer">Proximal</a>，
    等等）</li>
</ul>
<p>甚至还包括 <a href="https://arxiv.org/abs/1606.04474">NN 驱动的优化器</a>。</p>
<p><a name="outliers"></a>
</p><h2 class="hide-from-toc">离群值 (outlier)</h2><p></p>
<p>与大多数其他值差别很大的值。在机器学习中，下列所有值都是离群值。</p>
<ul>
<li>绝对值很高的<a href="#weight"><strong>权重</strong></a>。</li>
<li>与实际值相差很大的预测值。</li>
<li>值比平均值高大约 3 个标准偏差的输入数据。</li>
</ul>
<p>离群值常常会导致模型训练出现问题。</p>
<p><a name="output_layer"></a>
</p><h2 class="hide-from-toc">输出层 (output layer)</h2><p></p>
<p>神经网络的“最后”一层，也是包含答案的层。</p>
<p><a name="overfitting"></a>
</p><h2 class="hide-from-toc">过拟合 (overfitting)</h2><p></p>
<p>创建的模型与<a href="#training_set"><strong>训练数据</strong></a>过于匹配，以致于模型无法根据新数据做出正确的预测。</p>
<h2 class="glossary">P</h2>

<p><a name="pandas"></a>
</p><h2 class="hide-from-toc">Pandas</h2><p></p>
<p>面向列的数据分析 API。很多机器学习框架（包括 TensorFlow）都支持将 Pandas 数据结构作为输入。请参阅 <a href="http://pandas.pydata.org/">Pandas 文档</a>。</p>
<p><a name="parameter"></a>
</p><h2 class="hide-from-toc">参数 (parameter)</h2><p></p>
<p>机器学习系统自行训练的模型的变量。例如，<a href="#weight"><strong>权重</strong></a>就是一种参数，它们的值是机器学习系统通过连续的训练迭代逐渐学习到的。与<a href="#hyperparameter"><strong>超参数</strong></a>相对。</p>
<p><a name="Parameter_Server"></a>
</p><h2 class="hide-from-toc">参数服务器 (PS, Parameter Server)</h2><p></p>
<p>一种作业，负责在分布式设置中跟踪模型<a href="#parameter"><strong>参数</strong></a>。</p>
<p><a name="parameter_update"></a>
</p><h2 class="hide-from-toc">参数更新 (parameter update)</h2><p></p>
<p>在训练期间（通常是在<a href="#gradient_descent"><strong>梯度下降法</strong></a>的单次迭代中）调整模型<a href="#parameter"><strong>参数</strong></a>的操作。</p>
<p><a name="partial_derivative"></a>
</p><h2 class="hide-from-toc">偏导数 (partial derivative)</h2><p></p>
<p>一种导数，除一个变量之外的所有变量都被视为常量。例如，f(x, y) 对 x 的偏导数就是 f(x) 的导数（即，使 y 保持恒定）。<em></em><em></em><em></em><em></em><em></em>f 对 x 的偏导数仅关注 x 如何变化，而忽略公式中的所有其他变量。<em></em><em></em><em></em></p>
<p><a name="partitioning_strategy"></a>
</p><h2 class="hide-from-toc">分区策略 (partitioning strategy)</h2><p></p>
<p><a href="#Parameter_Server"><strong>参数服务器</strong></a>中分割变量的算法。</p>

</p><p><a name="performance"></a>
</p><h2 class="hide-from-toc">性能 (performance)</h2><p></p>
<p>多含义术语，具有以下含义：</p>
<ul>
<li>在软件工程中的传统含义。即：相应软件的运行速度有多快（或有多高效）？</li>
<li>在机器学习中的含义。在机器学习领域，性能旨在回答以下问题：相应<a href="#model"><strong>模型</strong></a>的准确度有多高？即模型在预测方面的表现有多好？</li>
</ul>
<p><a name="perplexity"></a>
</p><h2 class="hide-from-toc">困惑度 (perplexity)</h2><p></p>
<p>一种衡量指标，用于衡量<a href="#model"><strong>模型</strong></a>能够多好地完成任务。例如，假设任务是读取用户使用智能手机键盘输入字词时输入的前几个字母，然后列出一组可能的完整字词。此任务的困惑度 (P) 是：为了使列出的字词中包含用户尝试输入的实际字词，您需要提供的猜测项的个数。</p>
<p>困惑度与<a href="#cross-entropy"><strong>交叉熵</strong></a>的关系如下：</p>
<div>
$$P= 2^{-\text{cross entropy}}$$
</div>

<p><a name="pipeline"></a>
</p><h2 class="hide-from-toc">流水线 (pipeline)</h2><p></p>
<p>机器学习算法的基础架构。流水线包括收集数据、将数据放入训练数据文件、训练一个或多个模型，以及将模型导出到生产环境。</p>
<p><a name="positive_class"></a>
</p><h2 class="hide-from-toc">正类别 (positive class)</h2><p></p>
<p>在<a href="#binary_classification"><strong>二元分类</strong></a>中，两种可能的类别分别被标记为正类别和负类别。正类别结果是我们要测试的对象。（不可否认的是，我们会同时测试这两种结果，但只关注正类别结果。）例如，在医学检查中，正类别可以是“肿瘤”。在电子邮件分类器中，正类别可以是“垃圾邮件”。</p>
<p>与<a href="#negative_class"><strong>负类别</strong></a>相对。</p>
<p><a name="precision"></a>
</p><h2 class="hide-from-toc">精确率 (precision)</h2><p></p>
<p>一种<a href="#classification_model"><strong>分类模型</strong></a>指标。精确率指模型正确预测正类别的频率，<a href="#positive_class"><strong></strong></a>即：</p>
<div>
$$\text{精确率} = \frac{\text{真正例数}} {\text{真正例数} + \text{假正例数}}$$
</div>

<p><a name="prediction"></a>
</p><h2 class="hide-from-toc">预测 (prediction)</h2><p></p>
<p>模型在收到输入的<a href="#example"><strong>样本</strong></a>后的输出。</p>
<p><a name="prediction_bias"></a>
</p><h2 class="hide-from-toc">预测偏差 (prediction bias)</h2><p></p>
<p>一个值，用于表明<a href="#prediction"><strong>预测</strong></a>平均值与数据集中<a href="#label"><strong>标签</strong></a>的平均值相差有多大。</p>
<p><a name="pre-made_Estimator"></a>
</p><h2 class="hide-from-toc">预创建的 Estimator (pre-made Estimator)</h2><p></p>
<p>其他人已建好的 <a href="#Estimator"><strong>Estimator</strong></a>。TensorFlow 提供了一些预创建的 Estimator，包括 <code>DNNClassifier</code>、<code>DNNRegressor</code> 和 <code>LinearClassifier</code>。您可以按照<a href="https://tensorflow.google.cn/extend/estimators">这些说明</a>构建自己预创建的 Estimator。</p>
<p><a name="pre-trained_model"></a>
</p><h2 class="hide-from-toc">预训练模型 (pre-trained model)</h2><p></p>
<p>已经过训练的模型或模型组件（例如<a href="#embeddings"><strong>嵌套</strong></a>）。有时，您需要将预训练的嵌套馈送到<a href="#neural_network"><strong>神经网络</strong></a>。在其他时候，您的模型将自行训练嵌套，而不依赖于预训练的嵌套。</p>
<p><a name="prior_belief"></a>
</p><h2 class="hide-from-toc">先验信念 (prior belief)</h2><p></p>
<p>在开始采用相应数据进行训练之前，您对这些数据抱有的信念。例如，<a href="#L2_regularization"><strong>L<sub>2</sub> 正则化</strong></a>依赖的先验信念是<a href="#weight"><strong>权重</strong></a>应该很小且应以 0 为中心呈正态分布。</p>
<h2 class="glossary">Q</h2>

<p><a name="queue"></a>
</p><h2 class="hide-from-toc">队列 (queue)</h2><p></p>
<p>一种 TensorFlow <a href="#Operation"><strong>操作</strong></a>，用于实现队列数据结构。通常用于 I/O 中。</p>
<h2 class="glossary">R</h2>

<p><a name="rank"></a>
</p><h2 class="hide-from-toc">等级 (rank)</h2><p></p>
<p>机器学习中的一个多含义术语，可以理解为下列含义之一：</p>
<ul>
<li><a href="#tensor"><strong>张量</strong></a>中的维度数量。例如，标量等级为 0，向量等级为 1，矩阵等级为 2。</li>
<li>在将类别从最高到最低进行排序的机器学习问题中，类别的顺序位置。例如，行为排序系统可以将狗狗的奖励从最高（牛排）到最低（枯萎的羽衣甘蓝）进行排序。</li>
</ul>
<p><a name="rater"></a>
</p><h2 class="hide-from-toc">评分者 (rater)</h2><p></p>
<p>为<a href="#example"><strong>样本</strong></a>提供<a href="#label"><strong>标签</strong></a>的人。有时称为“注释者”。</p>
<p><a name="recall"></a>
</p><h2 class="hide-from-toc">召回率 (recall)</h2><p></p>
<p>一种<a href="#classification_model"><strong>分类模型</strong></a>指标，用于回答以下问题：在所有可能的正类别标签中，模型正确地识别出了多少个？即：</p>
<p>$$\text{召回率} = \frac{\text{真正例数}} {\text{真正例数} + \text{假负例数}}
$$</p>
<p><a name="ReLU"></a>
</p><h2 class="hide-from-toc">修正线性单元 (ReLU, Rectified Linear Unit)</h2><p></p>
<p>一种<a href="#activation_function"><strong>激活函数</strong></a>，其规则如下：</p>
<ul>
<li>如果输入为负数或 0，则输出 0。</li>
<li>如果输入为正数，则输出等于输入。</li>
</ul>
<p><a name="regression_model"></a>
</p><h2 class="hide-from-toc">回归模型 (regression model)</h2><p></p>
<p>一种模型，能够输出连续的值（通常为浮点值）。请与<a href="#classification_model"><strong>分类模型</strong></a>进行比较，分类模型输出离散值，例如“黄花菜”或“虎皮百合”。</p>
<p><a name="regularization"></a>
</p><h2 class="hide-from-toc">正则化 (regularization)</h2><p></p>
<p>对模型复杂度的惩罚。正则化有助于防止出现<a href="#overfitting"><strong>过拟合</strong></a>，包含以下类型：</p>
<ul>
<li><a href="#L1_regularization"><strong>L<sub>1</sub> 正则化</strong></a></li>
<li><a href="#L2_regularization"><strong>L<sub>2</sub> 正则化</strong></a></li>
<li><a href="#dropout_regularization"><strong>丢弃正则化</strong></a></li>
<li><a href="#early_stopping"><strong>早停法</strong></a>（这不是正式的正则化方法，但可以有效限制过拟合）</li>
</ul>
<p><a name="regularization_rate"></a>
</p><h2 class="hide-from-toc">正则化率 (regularization rate)</h2><p></p>
<p>一种标量值，以 lambda 表示，用于指定正则化函数的相对重要性。从下面简化的<a href="#loss"><strong>损失</strong></a>公式中可以看出正则化率的影响：</p>
<div>
$$\text{minimize(loss function + }\lambda\text{(regularization function))}$$
</div>

<p>提高正则化率可以减少<a href="#overfitting"><strong>过拟合</strong></a>，但可能会使模型的<a href="#accuracy"><strong>准确率</strong></a>降低。</p>
<p><a name="representation"></a>
</p><h2 class="hide-from-toc">表示法 (representation)</h2><p></p>
<p>将数据映射到实用<a href="#feature"><strong>特征</strong></a>的过程。</p>
<p><a name="ROC"></a>
</p><h2 class="hide-from-toc">受试者工作特征曲线（receiver operating characteristic, 简称 ROC 曲线）</h2><p></p>
<p>不同<a href="#classification_threshold"><strong>分类阈值</strong></a>下的<a href="#TP_rate"><strong>真正例率</strong></a>和<a href="#FP_rate"><strong>假正例率</strong></a>构成的曲线。另请参阅<a href="#AUC"><strong>曲线下面积</strong></a>。</p>
<p><a name="root_directory"></a>
</p><h2 class="hide-from-toc">根目录 (root directory)</h2><p></p>
<p>您指定的目录，用于托管多个模型的 TensorFlow 检查点和事件文件的子目录。</p>
<p><a name="RMSE"></a>
</p><h2 class="hide-from-toc">均方根误差 (RMSE, Root Mean Squared Error)</h2><p></p>
<p><a href="#MSE"><strong>均方误差</strong></a>的平方根。</p>
<h2 class="glossary">S</h2>

<p><a name="SavedModel"></a>
</p><h2 class="hide-from-toc">SavedModel</h2><p></p>
<p>保存和恢复 TensorFlow 模型时建议使用的格式。SavedModel 是一种独立于语言且可恢复的序列化格式，使较高级别的系统和工具可以创建、使用和转换 TensorFlow 模型。</p>
<p>如需完整的详细信息，请参阅《TensorFlow 编程人员指南》中的<a href="https://tensorflow.google.cn/programmers_guide/saved_model">保存和恢复</a>。</p>
<p><a name="Saver"></a>
</p><h2 class="hide-from-toc">Saver</h2><p></p>
<p>一种 <a href="https://tensorflow.google.cn/api_docs/python/tf/train/Saver">TensorFlow 对象</a>，负责保存模型检查点。</p>
<p><a name="scaling"></a>
</p><h2 class="hide-from-toc">缩放 (scaling)</h2><p></p>
<p><a href="#feature_engineering"><strong>特征工程</strong></a>中的一种常用做法，是对某个特征的值区间进行调整，使之与数据集中其他特征的值区间一致。例如，假设您希望数据集中所有浮点特征的值都位于 0 到 1 区间内，如果某个特征的值位于 0 到 500 区间内，您就可以通过将每个值除以 500 来缩放该特征。</p>
<p>另请参阅<a href="#normalization"><strong>标准化</strong></a>。</p>
<p><a name="scikit-learn"></a>
</p><h2 class="hide-from-toc">scikit-learn</h2><p></p>
<p>一个热门的开放源代码机器学习平台。请访问 <a href="http://www.scikit-learn.org/">www.scikit-learn.org</a>。</p>
<p><a name="semi-supervised_learning"></a>
</p><h2 class="hide-from-toc">半监督式学习 (semi-supervised learning)</h2><p></p>
<p>训练模型时采用的数据中，某些训练样本有标签，而其他样本则没有标签。半监督式学习采用的一种技术是推断无标签样本的标签，然后使用推断出的标签进行训练，以创建新模型。如果获得有标签样本需要高昂的成本，而无标签样本则有很多，那么半监督式学习将非常有用。</p>
<p><a name="sequence_model"></a>
</p><h2 class="hide-from-toc">序列模型 (sequence model)</h2><p></p>
<p>一种模型，其输入具有序列依赖性。例如，根据之前观看过的一系列视频对观看的下一个视频进行预测。</p>


</p><p><a name="session"></a>
</p><h2 class="hide-from-toc">会话 (session)</h2><p></p>
<p>维持 TensorFlow 程序中的状态（例如变量）。</p>

</p><p><a name="sigmoid_function"></a>
</p><h2 class="hide-from-toc">S 型函数 (sigmoid function)</h2><p></p>
<p>一种函数，可将逻辑回归输出或多项回归输出（对数几率）映射到概率，以返回介于 0 到 1 之间的值。S 型函数的公式如下：</p>
<div>
$$y = \frac{1}{1 + e^{-\sigma}}$$
</div>

<p>在<a href="#logistic_regression"><strong>逻辑回归</strong></a>问题中，\(\sigma\) 非常简单：</p>
<div>
$$\sigma = b + w_1x_1 + w_2x_2 + … w_nx_n$$
</div>

<p>换句话说，S 型函数可将 \(\sigma\) 转换为介于 0 到 1 之间的概率。</p>
<p>在某些<a href="#neural_network"><strong>神经网络</strong></a>中，S 型函数可作为<a href="#activation_function"><strong>激活函数</strong></a>使用。</p>
<p><a name="softmax"></a>
</p><h2 class="hide-from-toc">softmax</h2><p></p>
<p>一种函数，可提供<a href="#multi-class"><strong>多类别分类模型</strong></a>中每个可能类别的概率。这些概率的总和正好为 1.0。例如，softmax 可能会得出某个图像是狗、猫和马的概率分别是 0.9、0.08 和 0.02。（也称为<strong>完整 softmax</strong>。）</p>
<p>与<a href="#candidate_sampling"><strong>候选采样</strong></a>相对。</p>
<p><a name="sparse_features"></a>
</p><h2 class="hide-from-toc">稀疏特征 (sparse feature)</h2><p></p>
<p>一种<a href="#feature"><strong>特征</strong></a>向量，其中的大多数值都为 0 或为空。例如，某个向量包含一个为 1 的值和一百万个为 0 的值，则该向量就属于稀疏向量。再举一个例子，搜索查询中的单词也可能属于稀疏特征 - 在某种指定语言中有很多可能的单词，但在某个指定的查询中仅包含其中几个。</p>
<p>与<a href="#dense_feature"><strong>密集特征</strong></a>相对。</p>
<p><a name="squared_hinge_loss"></a>
</p><h2 class="hide-from-toc">平方合页损失函数 (squared hinge loss)</h2><p></p>
<p><a href="#hinge-loss"><strong>合页损失函数</strong></a>的平方。与常规合页损失函数相比，平方合页损失函数对离群值的惩罚更严厉。</p>
<p><a name="squared_loss"></a>
</p><h2 class="hide-from-toc">平方损失函数 (squared loss)</h2><p></p>
<p>在<a href="#linear_regression"><strong>线性回归</strong></a>中使用的<a href="#loss"><strong>损失</strong></a>函数（也称为 <strong>L<sub>2</sub> 损失函数</strong>）。该函数可计算模型为有标签<a href="#example"><strong>样本</strong></a>预测的值和<a href="#label"><strong>标签</strong></a>的实际值之差的平方。由于取平方值，因此该损失函数会放大不佳预测的影响。也就是说，与 <a href="#L1_loss"><strong>L<sub>1</sub> 损失函数</strong></a>相比，平方损失函数对离群值的反应更强烈。</p>
<p><a name="static_model"></a>
</p><h2 class="hide-from-toc">静态模型 (static model)</h2><p></p>
<p>离线训练的一种模型。</p>
<p><a name="stationarity"></a>
</p><h2 class="hide-from-toc">平稳性 (stationarity)</h2><p></p>
<p>数据集中数据的一种属性，表示数据分布在一个或多个维度保持不变。这种维度最常见的是时间，即表明平稳性的数据不随时间而变化。例如，从 9 月到 12 月，表明平稳性的数据没有发生变化。</p>
<p><a name="step"></a>
</p><h2 class="hide-from-toc">步 (step)</h2><p></p>
<p>对一个<a href="#batch"><strong>批次</strong></a>的向前和向后评估。</p>
<p><a name="step_size"></a>
</p><h2 class="hide-from-toc">步长 (step size)</h2><p></p>
<p>是<a href="#learning_rate"><strong>学习速率</strong></a>的同义词。</p>
<p><a name="SGD"></a>
</p><h2 class="hide-from-toc">随机梯度下降法 (SGD, stochastic gradient descent)</h2><p></p>
<p>批次规模为 1 的一种<a href="#gradient_descent"><strong>梯度下降法</strong></a>。换句话说，SGD 依赖于从数据集中随机均匀选择的单个样本来计算每步的梯度估算值。</p>
<p><a name="SRM"></a>
</p><h2 class="hide-from-toc">结构风险最小化 (SRM, structural risk minimization)</h2><p></p>
<p>一种算法，用于平衡以下两个目标：</p>
<ul>
<li>期望构建最具预测性的模型（例如损失最低）。</li>
<li>期望使模型尽可能简单（例如强大的正则化）。</li>
</ul>
<p>例如，旨在将基于训练集的损失和正则化降至最低的模型函数就是一种结构风险最小化算法。</p>
<p>如需更多信息，请参阅 <a href="http://www.svms.org/srm/">http://www.svms.org/srm/</a>。</p>
<p>与<a href="#ERM"><strong>经验风险最小化</strong></a>相对。</p>
<p><a name="summary"></a>
</p><h2 class="hide-from-toc">总结 (summary)</h2><p></p>
<p>在 TensorFlow 中的某一<a href="#step"><strong>步</strong></a>计算出的一个值或一组值，通常用于在训练期间跟踪模型指标。</p>
<p><a name="supervised_machine_learning"></a>
</p><h2 class="hide-from-toc">监督式机器学习 (supervised machine learning)</h2><p></p>
<p>根据输入数据及其对应的<a href="#label"><strong>标签</strong></a>来训练<a href="#model"><strong>模型</strong></a>。监督式机器学习类似于学生通过研究一系列问题及其对应的答案来学习某个主题。在掌握了问题和答案之间的对应关系后，学生便可以回答关于同一主题的新问题（以前从未见过的问题）。请与<a href="#unsupervised_machine_learning"><strong>非监督式机器学习</strong></a>进行比较。</p>
<p><a name="synthetic_feature"></a>
</p><h2 class="hide-from-toc">合成特征 (synthetic feature)</h2><p></p>
<p>一种<a href="#feature"><strong>特征</strong></a>，不在输入特征之列，而是从一个或多个输入特征衍生而来。合成特征包括以下类型：</p>
<ul>
<li>将一个特征与其本身或其他特征相乘（称为<a href="#feature_cross"><strong>特征组合</strong></a>）。</li>
<li>两个特征相除。</li>
<li>对连续特征进行<a href="#bucketing"><strong>分桶</strong></a>，以分为多个区间分箱。</li>
</ul>
<p>通过<a href="#normalization"><strong>标准化</strong></a>或<a href="#scaling"><strong>缩放</strong></a>单独创建的特征不属于合成特征。</p>
<h2 class="glossary">T</h2>

<p><a name="target"></a>
</p><h2 class="hide-from-toc">目标 (target)</h2><p></p>
<p>是<a href="#label"><strong>标签</strong></a>的同义词。</p>
<p><a name="temporal_data"></a>
</p><h2 class="hide-from-toc">时态数据 (temporal data)</h2><p></p>
<p>在不同时间点记录的数据。例如，记录的一年中每一天的冬外套销量就属于时态数据。</p>
<p><a name="tensor"></a>
</p><h2 class="hide-from-toc">张量 (Tensor)</h2><p></p>
<p>TensorFlow 程序中的主要数据结构。张量是 N 维（其中 N 可能非常大）数据结构，最常见的是标量、向量或矩阵。张量的元素可以包含整数值、浮点值或字符串值。</p>
<p><a name="TPU"></a>
</p><h2 class="hide-from-toc">张量处理单元 (TPU, Tensor Processing Unit)</h2><p></p>
<p>一种 ASIC（应用专用集成电路），用于优化 TensorFlow 程序的性能。</p>
<p><a name="tensor_rank"></a>
</p><h2 class="hide-from-toc">张量等级 (Tensor rank)</h2><p></p>
<p>请参阅<a href="#rank"><strong>等级</strong></a>。</p>
<p><a name="tensor_shape"></a>
</p><h2 class="hide-from-toc">张量形状 (Tensor shape)</h2><p></p>
<p><a href="#tensor"><strong>张量</strong></a>在各种维度中包含的元素数。例如，张量 [5, 10] 在一个维度中的形状为 5，在另一个维度中的形状为 10。</p>
<p><a name="tensor_size"></a>
</p><h2 class="hide-from-toc">张量大小 (Tensor size)</h2><p></p>
<p><a href="#tensor"><strong>张量</strong></a>包含的标量总数。例如，张量 [5, 10] 的大小为 50。</p>
<p><a name="TensorBoard"></a>
</p><h2 class="hide-from-toc">TensorBoard</h2><p></p>
<p>一个信息中心，用于显示在执行一个或多个 TensorFlow 程序期间保存的摘要信息。</p>
<p><a name="TensorFlow"></a>
</p><h2 class="hide-from-toc">TensorFlow</h2><p></p>
<p>一个大型的分布式机器学习平台。该术语还指 TensorFlow 堆栈中的基本 API 层，该层支持对数据流图进行一般计算。</p>
<p>虽然 TensorFlow 主要应用于机器学习领域，但也可用于需要使用数据流图进行数值计算的非机器学习任务。</p>
<p><a name="TensorFlow_Playground"></a>
</p><h2 class="hide-from-toc">TensorFlow Playground</h2><p></p>
<p>一款用于直观呈现不同的<a href="#hyperparameters"><strong>超参数</strong></a>对模型（主要是神经网络）训练的影响的程序。要试用 TensorFlow Playground，请前往 <a href="http://playground.tensorflow.org">http://playground.tensorflow.org</a>。</p>
<p><a name="TensorFlow_Serving"></a>
</p><h2 class="hide-from-toc">TensorFlow Serving</h2><p></p>
<p>一个平台，用于将训练过的模型部署到生产环境。</p>
<p><a name="test_set"></a>
</p><h2 class="hide-from-toc">测试集 (test set)</h2><p></p>
<p>数据集的子集，用于在<a href="#model"><strong>模型</strong></a>经由验证集的初步验证之后测试模型。

</p><p>与<a href="#training_set"><strong>训练集</strong></a>和<a href="#validation_set"><strong>验证集</strong></a>相对。</p>
<p><a name="tf.Example"></a>
</p><h2 class="hide-from-toc">tf.Example</h2><p></p>
<p>一种标准的 <a href="https://developers.google.cn/protocol-buffers/">proto buffer</a>，旨在描述用于机器学习模型训练或推断的输入数据。</p>
<p><a name="time_series_analysis"></a>
</p><h2 class="hide-from-toc">时间序列分析 (time series analysis)</h2><p></p>
<p>机器学习和统计学的一个子领域，旨在分析<a href="#temporal_data"><strong>时态数据</strong></a>。很多类型的机器学习问题都需要时间序列分析，其中包括分类、聚类、预测和异常检测。例如，您可以利用时间序列分析根据历史销量数据预测未来每月的冬外套销量。</p>
<p><a name="training"></a>
</p><h2 class="hide-from-toc">训练 (training)</h2><p></p>
<p>确定构成模型的理想<a href="#parameter"><strong>参数</strong></a>的过程。</p>
<p><a name="training_set"></a>
</p><h2 class="hide-from-toc">训练集 (training set)</h2><p></p>
<p>数据集的子集，用于训练模型。</p>
<p>与<a href="#validation_set"><strong>验证集</strong></a>和<a href="#test_set"><strong>测试集</strong></a>相对。</p>
<p><a name="transfer_learning"></a>
</p><h2 class="hide-from-toc">转移学习 (transfer learning)</h2><p></p>
<p>将信息从一个机器学习任务转移到另一个机器学习任务。例如，在多任务学习中，一个模型可以完成多项任务，例如针对不同任务具有不同输出节点的<a href="#deep_model"><strong>深度模型</strong></a>。转移学习可能涉及将知识从较简单任务的解决方案转移到较复杂的任务，或者将知识从数据较多的任务转移到数据较少的任务。</p>
<p>大多数机器学习系统都只能完成一项任务。<em></em>转移学习是迈向人工智能的一小步；在人工智能中，单个程序可以完成多项任务。<em></em></p>
<p><a name="TN"></a>
</p><h2 class="hide-from-toc">真负例 (TN, true negative)</h2><p></p>
<p>被模型正确地预测为<a href="#negative_class"><strong>负类别</strong></a>的样本。<em></em>例如，模型推断出某封电子邮件不是垃圾邮件，而该电子邮件确实不是垃圾邮件。</p>
<p><a name="TP"></a>
</p><h2 class="hide-from-toc">真正例 (TP, true positive)</h2><p></p>
<p>被模型正确地预测为<a href="#positive_class"><strong>正类别</strong></a>的样本。<em></em>例如，模型推断出某封电子邮件是垃圾邮件，而该电子邮件确实是垃圾邮件。</p>
<p><a name="TP_rate"></a>
</p><h2 class="hide-from-toc">真正例率（true positive rate, 简称 TP 率）</h2><p></p>
<p>是<a href="#recall"><strong>召回率</strong></a>的同义词，即：</p>
<div>
$$\text{真正例率} = \frac{\text{真正例数}} {\text{真正例数} + \text{假负例数}}$$
</div>

<p>真正例率是 <a href="#ROC"><strong>ROC 曲线</strong></a>的 y 轴。</p>
<h2 class="glossary">U</h2>

<p><a name="unlabeled_example"></a>
</p><h2 class="hide-from-toc">无标签样本 (unlabeled example)</h2><p></p>
<p>包含<a href="#feature"><strong>特征</strong></a>但没有<a href="#label"><strong>标签</strong></a>的样本。无标签样本是用于进行<a href="#inference"><strong>推断</strong></a>的输入内容。在<a href="#semi-supervised_learning"><strong>半监督式</strong></a>和<a href="#unsupervised_machine_learning"><strong>非监督式</strong></a>学习中，无标签样本在训练期间被使用。</p>
<p><a name="unsupervised_machine_learning"></a>
</p><h2 class="hide-from-toc">非监督式机器学习 (unsupervised machine learning)</h2><p></p>
<p>训练<a href="#model"><strong>模型</strong></a>，以找出数据集（通常是无标签数据集）中的模式。</p>
<p>非监督式机器学习最常见的用途是将数据分为不同的聚类，使相似的样本位于同一组中。例如，非监督式机器学习算法可以根据音乐的各种属性将歌曲分为不同的聚类。所得聚类可以作为其他机器学习算法（例如音乐推荐服务）的输入。在很难获取真标签的领域，聚类可能会非常有用。例如，在反滥用和反欺诈等领域，聚类有助于人们更好地了解相关数据。</p>
<p>非监督式机器学习的另一个例子是<a href="https://en.wikipedia.org/wiki/Principal_component_analysis"><strong>主成分分析 (PCA)</strong></a>。例如，通过对包含数百万购物车中物品的数据集进行主成分分析，可能会发现有柠檬的购物车中往往也有抗酸药。</p>
<p>请与<a href="#supervised_machine_learning"><strong>监督式机器学习</strong></a>进行比较。</p>
<h2 class="glossary">V</h2>

<p><a name="validation_set"></a>
</p><h2 class="hide-from-toc">验证集 (validation set)</h2><p></p>
<p>数据集的一个子集，从训练集分离而来，用于调整<a href="#hyperparameter"><strong>超参数</strong></a>。</p>
<p>与<a href="#training_set"><strong>训练集</strong></a>和<a href="#test_set"><strong>测试集</strong></a>相对。</p>

</p><h2 class="glossary">W</h2>

<p><a name="weight"></a>
</p><h2 class="hide-from-toc">权重 (weight)</h2><p></p>
<p>线性模型中<a href="#feature"><strong>特征</strong></a>的系数，或深度网络中的边。训练线性模型的目标是确定每个特征的理想权重。如果权重为 0，则相应的特征对模型来说没有任何贡献。</p>
<p><a name="wide_model"></a>
</p><h2 class="hide-from-toc">宽度模型 (wide model)</h2><p></p>
<p>一种线性模型，通常有很多<a href="#sparse_features"><strong>稀疏输入特征</strong></a>。我们之所以称之为“宽度模型”，是因为这是一种特殊类型的<a href="#neural_network"><strong>神经网络</strong></a>，其大量输入均直接与输出节点相连。与深度模型相比，宽度模型通常更易于调试和检查。虽然宽度模型无法通过<a href="#hidden_layer"><strong>隐藏层</strong></a>来表示非线性关系，但可以利用<a href="#feature_cross"><strong>特征组合</strong></a>、<a href="#bucketing"><strong>分桶</strong></a>等转换以不同的方式为非线性关系建模。</p>
<p>与<a href="#deep_model"><strong>深度模型</strong></a>相对。</p>


  </div>
  

  
        
  







        
<div class="devsite-content-footer nocontent">
  
</html>
